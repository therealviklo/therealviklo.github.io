<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1">
		<link rel="icon" type="image/png" href="/favicon.png">
		<title>Unicode analyser</title>
		<link rel="stylesheet" href="/style.css">

		<style>
			textarea
			{
				width: 100%;
				box-sizing: border-box;
				height: 5.5rem;
			}

			#charinfo div
			{
				display: flex;
				height: 1.1666666em;
			}

			.charDisplay
			{
				display: inline-block;
				width: 1.5em;
				text-align: center;
				overflow: hidden;
			}

			.charCode
			{
				display: inline-block;
				width: 5em;
			}

			.charFormalalias
			{
				font-style: italic;
			}
		</style>
		<script>
			let textPlaceholder = "Example";
			let unicodePlaceholder = "U+0045 U+0078 U+0061 U+006D U+0070 U+006C U+0065";
			let namesList = null;

			function placeholderCheck(text, unicode)
			{
				if (text.value.length == 0 && unicode.value.length == 0)
				{
					text.placeholder = textPlaceholder;
					unicode.placeholder = unicodePlaceholder;
				}
				else
				{
					text.placeholder = "";
					unicode.placeholder = "";
				}
			}

			function padWithZeroes(str, num)
			{
				if (str.length < num)
					return "0".repeat(num - str.length) + str;
				return str;
			}

			function codePointHexcode(codePoint)
			{
				return padWithZeroes(codePoint.codePointAt(0).toString(16).toUpperCase(), 4);
			}

			function textChanged()
			{
				const text = document.getElementById("text");
				const unicode = document.getElementById("unicode");
				const textString = text.value;
				let newUnicode = "";
				for (const codePoint of textString)
				{
					if (newUnicode != "")
						newUnicode += " ";
					newUnicode += "U+" + codePointHexcode(codePoint);
				}
				unicode.value = newUnicode;
				placeholderCheck(text, unicode);
				generateInfoList();
			}

			function unicodeChanged()
			{
				const text = document.getElementById("text");
				const unicode = document.getElementById("unicode");
				const sanitisedUnicode = unicode.value.replace(/[^Uu+0-9A-Fa-f\s]/g, "");
				unicode.value = sanitisedUnicode;
				const nums = sanitisedUnicode.replace(/[Uu+]/g, "").split(/\s/g);
				let newText = "";
				nums.forEach(i => {
					if (i != "")
					{
						let num = parseInt(i, 16);
						newText += String.fromCodePoint(num);
					}
				});
				text.value = newText;
				placeholderCheck(text, unicode);
				generateInfoList();
			}

			function switchLanguage()
			{
				document.title = "Unicodeanalysator";
				document.getElementById("mainTitle").innerText = "Unicodeanalysator";
				document.getElementById("unicodeTitle").innerText = "Unicodekodpunkter";
				document.getElementById("explanation").innerText = "Textrutan under \"Unicodekodpunkter\" visar Unicodekodpunkterna för texten i textrutan under \"Text\". Båda textrutorna kan ändras, vilket också får den andra textrutan att uppdatera.";
				textPlaceholder = "Exempel";
				unicodePlaceholder = "U+0045 U+0078 U+0065 U+006D U+0070 U+0065 U+006C";
				unicodeChanged();
			}

			function checkLanguage()
			{
				if (navigator.language.startsWith("sv-") || navigator.language == "sv")
				{
					switchLanguage();
				}
			}

			function generateInfoList()
			{
				if (namesList)
				{
					const charinfo = document.getElementById("charinfo");
					charinfo.textContent = "";
					const text = document.getElementById("text").value;
					for (const c of text)
					{
						const element = document.createElement("div");
						const charDisplay = document.createElement("span");
						charDisplay.setAttribute("class", "charDisplay");
						charDisplay.appendChild(document.createTextNode(c));
						element.appendChild(charDisplay);
						const charCode = document.createElement("span");
						charCode.setAttribute("class", "charCode");
						charCode.appendChild(document.createTextNode("U+" + codePointHexcode(c)));
						element.appendChild(charCode);
						const ci = namesList[c.codePointAt(0)];
						if (ci)
						{
							const charName = document.createElement("span");
							charName.setAttribute("class", "charName");
							charName.appendChild(document.createTextNode(ci["name"]));
							if (ci["formalaliases"].length > 0)
							{
								const charFormalalias = document.createElement("span");
								charFormalalias.setAttribute("class", "charFormalalias");
								charFormalalias.appendChild(document.createTextNode(
									" (" + ci["formalaliases"][ci["formalaliases"].length - 1] + ")"
								));
								charName.appendChild(charFormalalias);
							}
							element.appendChild(charName);
						}
						charinfo.appendChild(element);
					}
					document.getElementById("charinfoSection").hidden = text.length == 0;
				}
			}

			function loadNamesList()
			{
				fetch("/unicode/NamesList.txt").then(value => value.text().then(value => {
					let namesListTmp = {};
					const matches = value.matchAll(/^[^;@].*$/gm);
					let currCharCode = null;
					for (const i of matches)
					{
						let match = i[0].match(/^[0-9A-F]{4,}\s+.+$/g)
						if (match)
						{
							let iter = match[0].matchAll(/[^\t]+/g);
							currCharCode = parseInt(iter.next().value[0], 16);
							const name = iter.next().value[0];
							namesListTmp[currCharCode] = {
								"name": name,
								"comments": [],
								"aliases": [],
								"formalaliases": [],
								"crossrefs": [],
								"variations": [],
								"decompositions": [],
								"compatmapping": []
							};
							continue;
						}
						if (!currCharCode)
							continue;
						match = i[0].match(/(?<=^\s*)[*=%x~:#] .+$/g);
						if (match)
						{
							const text = match[0].substr(2);
							switch (match[0][0])
							{
								case '*':
									namesListTmp[currCharCode].comments.push(text);
									break;
								case '=':
									namesListTmp[currCharCode].aliases.push(text);
									break;
								case '%':
									namesListTmp[currCharCode].formalaliases.push(text);
									break;
								case 'x':
									namesListTmp[currCharCode].crossrefs.push(text);
									break;
								case '~':
									namesListTmp[currCharCode].variations.push(text);
									break;
								case ':':
									namesListTmp[currCharCode].decompositions.push(text);
									break;
								case '#':
									namesListTmp[currCharCode].compatmapping.push(text);
									break;
							}
							continue;
						}
					}
					namesList = namesListTmp;
					generateInfoList();
				}));
			}

			document.addEventListener("DOMContentLoaded", event => checkLanguage());
			document.addEventListener("DOMContentLoaded", event => loadNamesList());
		</script>
	</head>
	<body>
		<iframe src="/header.html" id="header"></iframe>
		<div class="block">
			<h1 id="mainTitle">Unicode analyser</h1>
			<p id="explanation">The box labelled "Unicode" displays the Unicode code points of the text in the box labelled "Text". Editing either box will cause the other to update.</p>
			<h2 id="textTitle">Text</h2>
			<textarea rows="5" id="text" oninput="textChanged()" placeholder="Example"></textarea>
			<h2 id="unicodeTitle">Unicode code points</h2>
			<textarea rows="5" id="unicode" oninput="unicodeChanged()" placeholder="U+0045 U+0078 U+0061 U+006D U+0070 U+006C U+0065"></textarea>
			<div id="charinfoSection" hidden>
				<h2>Character Info</h2>
				<div id="charinfo"></div>
			</div>
		</div>
	</body>
</html>